<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      lrzsz | Sail 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Sail">


    
    

<div id="site_search">
            <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control">
            <div id="local-search-result"></div>
    </div>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-1345496474366685",
        enable_page_level_ads: true
      });
    </script>


    <meta name="description" content="preface 从前在学校做开发的时候,有一件事情弄得特别麻烦,那就是本机与服务器(Linux)的文件传输问题。 当时我有两个解决方案:一个是通过WinSCP,这个桌面软件勾选本地文件上传到服务器相应的目录。二则是将代码等文件上传到github,然后服务端clone下来。 前几个月到百度来实习,第一天搭建机器环境的时候,才知道lrzsz这个软件。lrzsz是一款在linux里可代替ftp上传和下">
<meta name="keywords" content="利器,计算机网络,文件传输协议">
<meta property="og:type" content="article">
<meta property="og:title" content="lrzsz | Sail">
<meta property="og:url" content="http://www.sail.name/2018/03/10/lrzsz/index.html">
<meta property="og:site_name" content="Sail">
<meta property="og:description" content="preface 从前在学校做开发的时候,有一件事情弄得特别麻烦,那就是本机与服务器(Linux)的文件传输问题。 当时我有两个解决方案:一个是通过WinSCP,这个桌面软件勾选本地文件上传到服务器相应的目录。二则是将代码等文件上传到github,然后服务端clone下来。 前几个月到百度来实习,第一天搭建机器环境的时候,才知道lrzsz这个软件。lrzsz是一款在linux里可代替ftp上传和下">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-09T10:19:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lrzsz | Sail">
<meta name="twitter:description" content="preface 从前在学校做开发的时候,有一件事情弄得特别麻烦,那就是本机与服务器(Linux)的文件传输问题。 当时我有两个解决方案:一个是通过WinSCP,这个桌面软件勾选本地文件上传到服务器相应的目录。二则是将代码等文件上传到github,然后服务端clone下来。 前几个月到百度来实习,第一天搭建机器环境的时候,才知道lrzsz这个软件。lrzsz是一款在linux里可代替ftp上传和下">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>

    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Sail</a></h1>
        <hr class="panel-cover__divider">

        
        <p class="panel-cover__description">
          手在键盘敲很轻
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>

              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>

              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>

              
               <li class="navigation__item">
                    <a href="http://www.sail.name/Resource/" title="个人资源分享">Resource</a></li>

            </ul>
          </nav>
          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">
    
      <!-- Github -->
      <li class="navigation__item">
        <a href="https://github.com/iamsail" title="Huno on GitHub">
          <i class="icon icon-social-github"></i>
          <span class="label">GitHub</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>


        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">lrzsz</h1>

    

    <div class="post-meta">
      <time datetime="2018-03-10" class="post-meta__date date">2018-03-10</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/Linux/">Linux</a>
            </font>
          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/利器/">利器</a>, <a class="tags-link" href="/tags/文件传输协议/">文件传输协议</a>, <a class="tags-link" href="/tags/计算机网络/">计算机网络</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="preface"><a href="#preface" class="headerlink" title=" preface "></a><strong> preface </strong></h3><p>从前在学校做开发的时候,有一件事情弄得特别麻烦,那就是本机与服务器(Linux)的文件传输问题。</p>
<p>当时我有两个解决方案:一个是通过<code>WinSCP</code>,这个桌面软件勾选本地文件上传到服务器相应的目录。二则是将代码等文件上传到github,然后服务端clone下来。</p>
<p>前几个月到百度来实习,第一天搭建机器环境的时候,才知道<a href="https://baike.baidu.com/item/lrzsz/5592701?fr=aladdin" target="_blank" rel="noopener">lrzsz</a>这个软件。<code>lrzsz</code>是一款在linux里可代替ftp上传和下载的程序。使用这个软件只需要一个命令就可以搞定本机和Linux的文件上传和下载问题了。</p>
<hr>
<h3 id="使用"><a href="#使用" class="headerlink" title=" 使用 "></a><strong> 使用 </strong></h3><h4 id="前提"><a href="#前提" class="headerlink" title=" 前提 "></a><strong> 前提 </strong></h4><p>1.Linux端（CentOS, Ubuntu）需要安装rz/sz命令，也就是 lszrz 包。</p>
<p>2.windows端需要支持ZModem的telnet/ssh客户端(Xshell,SecureCRT支持,putty不支持)</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title=" 缺点 "></a><strong> 缺点 </strong></h4><p>使用<code>lszrz</code>非常方便,但是无法传输大于4G的文件。这个时候就需要其他工具了,不过4G大部分情况应该都是够用的。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title=" 安装 "></a><strong> 安装 </strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install lrzsz | apt-get install lrzsz</span><br></pre></td></tr></table></figure>
<h4 id="sz、rz"><a href="#sz、rz" class="headerlink" title=" sz、rz "></a><strong> sz、rz </strong></h4><p><code>man rz</code><br>rz(Receive Zmodem),输入rz时、意为服务器接收文件,既将文件从本地上传到服务器。<br>sz(Send Zmodem),输入sz时、意为服务器要发送文件,既从服务器发送文件到本地,或是说本地从服务器上下载文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 下载一个文件： </span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sz filename </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 下载多个文件： </span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sz filename1 filename2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 下载dir目录下的所有文件，不包含dir下的文件夹： </span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sz dir/*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##</span></span></span><br><span class="line">上传的时候，如果上传到的linux目录有同名的文件，是无法上传的，需要先删掉linux上的同名文件,或改名</span><br></pre></td></tr></table></figure>
<p>那如何传输整个目录的文件呢？<strong> 我们需要先将目录进行压缩,再进行传输 </strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## tar.gz格式</span></span></span><br><span class="line">解压$ tar zxvf FileName.tar.gz</span><br><span class="line">压缩$ tar zcvf FileName.tar.gz DirName</span><br></pre></td></tr></table></figure>
<h4 id="传输默认路径设置"><a href="#传输默认路径设置" class="headerlink" title=" 传输默认路径设置 "></a><strong> 传输默认路径设置 </strong></h4><p>Xshell:文件-&gt;属性-&gt;文件传输 中进行设置<br>SecureCRT:选项-&gt;会话选项-&gt;X/Y/Zmodem 中进行设置</p>
<hr>
<h3 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title=" 文件传输协议 "></a><strong> 文件传输协议 </strong></h3><p>以前我只知道<a href="https://baike.baidu.com/item/ftp/13839?fr=aladdin" target="_blank" rel="noopener">FTP即File Transfer Protocol（文件传输协议）</a>。其实这下面是有一些细分的协议的。</p>
<p>百度百科上是这样说的</p>
<p><strong><span class="under0"> FTP的传输有两种方式：ASCII、二进制。</span></strong></p>
<h4 id="ASCII传输方式"><a href="#ASCII传输方式" class="headerlink" title=" ASCII传输方式 "></a><strong> ASCII传输方式 </strong></h4><p>假定用户正在拷贝的文件包含的简单ASCII码文本，如果在远程机器上运行的不是UNIX，当文件传输时ftp通常会自动地调整文件的内容以便于把文件解释成另外那台计算机存储文本文件的格式。<br>但是常常有这样的情况，用户正在传输的文件包含的不是文本文件，它们可能是程序，数据库，字处理文件或者压缩文件。在拷贝任何非文本文件之前，用binary 命令告诉ftp逐字拷贝。</p>
<h4 id="二进制传输模式"><a href="#二进制传输模式" class="headerlink" title=" 二进制传输模式 "></a><strong> 二进制传输模式 </strong></h4><p>在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。即使目的地机器上包含位序列的文件是没意义的。例如，macintosh以二进制方式传送可执行文件到Windows系统，在对方系统上，此文件不能执行。<br>如在ASCII方式下传输二进制文件，即使不需要也仍会转译。这会损坏数据。（ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。如果传输二进制文件，所有的位都是重要的。）</p>
<hr>
<h3 id="几种流行的文件传输协议"><a href="#几种流行的文件传输协议" class="headerlink" title=" 几种流行的文件传输协议 "></a><strong> 几种流行的文件传输协议 </strong></h3><p>在某个电子论坛看到的这篇文章,搬运过来,链接见文末参考。</p>
<p>在联机通信中，人们经常要使用文件传输协议（FileTransfer Protocols）上装或下载文件。我们知道，计算机内部的并行数据在发送到调制解调器之前，必须要转换成串行数据，并给每个字节附加一个起始位和一个停止位，以便使收信系统能准确判断任一字节的开始和结束。<strong> 早期的联机通信中，几乎每个字节都是这样直来直去传送，人们称这种没有任何纠错能力的传输方式为ASCⅡ码传送方式，还有的人则干脆称其为ASCⅡ协议，在有些通信软件的文件传输协议的选择项中也常常有ASCⅡ的选项。</strong>由于ASCⅡ码的传输只是字节流的传送，因而在传输线路状态不佳时就会出现数据丢失、系统死机、通信中断等错误。在ASCⅡ字符集中“＄”符号的数据串是“100100”，如果线路瞬间干扰使前面的“l”丢失变为“0”，成了“100”，也就是字符“D”。ASCⅡ字符集中的“D”（E OT）是标志文件传输结束的符号，接收系统收到该字符后就立即停止数据的接收。<br>.随着人们对数据传输质量的更高要求及对各种方便 传送的需要，多种性能各异的具有检错能力的二进制文件传输协议便相继开发出来。<strong> 二进制文件传输协议不象ASCⅡ传输方式那样一个字节一个字节的依次传送，而是把许多个字节“打”成一定长度的“包”（Packet），并给每个包加上一些能够检错的字节进行传送。也有的人把这种传送叫“块”（Block）传送或是“帧”（Frame）传送。</strong>对方的计算机收到此“包”，必须进行“拆包”（Unpack）处理，才能还原正文内容。“包”的大小团协议不同而有差异，或是128个字节，或是1，024个字节，若尾包的文件字节很少，则采用空字符NUL“补位”的办法把“包”填满。在文件传送过程中，只要收发的协议一致，系统就会在协议约定的状态下，完成控制信号、错误确认及标记等各种传输工作。<strong> 尽管这些协议至今仍没有得到官方的认可，但其可靠的传输性能却受到使用者的青睐，得到了迅速推广，成为事实上的文件传输协议，并被广泛应用在包括Internet在内的各种联机系统中。</strong><br>二进制文件传输协议有很多种，本文不能详尽叙述，只能介绍几种目前较为流行的协议，供使用时参考。</p>
<h4 id="1-XModem"><a href="#1-XModem" class="headerlink" title=" 1.XModem "></a><strong> 1.XModem </strong></h4><p>XModem又叫Modem7或XModem/checsum（校验和），是较早出现并被广泛使用的二进制文件传输协议，有较强的检错能力。XModem“包”的大小为128字节，每个“包”都携带一个8Bit的“校验和”字节供接收系统检测。若接收检测的结果与“校验和”一致，接收系统就会发出ACK确认回答标志信号并请求传送下一个“包”的信息。若接收检测的结果与“校验和”不一致，接收系统则发出NAK否认回答标志信号，告诉发送系统传输出现错误，请求重传该“包”的内容，如此下去直到整个文件传送结束，或者在一定的时间内纠错无效退出传送状态。<br>XModem的传送可靠率能达到96％，缺点是只能以8个数据位的格式传送文件，而且在流控状态时易造成系统异常。</p>
<h4 id="2-XModem-CRC"><a href="#2-XModem-CRC" class="headerlink" title=" 2.XModem CRC"></a><strong> 2.XModem CRC</strong></h4><p>XModem CRC是在 XModem协议的基础上改进的版本。由于使用了CRC（循环冗余校验），每个“包”便有了两个“校验和”字节（16Bit),检错能力有了明显增强，使安全系数提高到99.6％以上。但因增加了检错字节使文件的传送时间有所延长，这种延长在长文件传送时最明显。值得一提的是，只有通信中的两个系统具备了CRC的条件才能进行循环冗余码校验，如果其中的一个系统不提供这种校验，另一系统就会自动转换成XModem协议的工作状态。另外，有些早期的通信软件不支持这样的操作，用户只能使用XModem协议。</p>
<h4 id="3-WModem"><a href="#3-WModem" class="headerlink" title=" 3.WModem "></a><strong> 3.WModem </strong></h4><p>WModem是由XModem协议演变而来的协议，也可以把它叫做“窗口式XModem”。WModem的工作过程比较特别，虽然每个“包”的容易也是128个字节，但它不象XModem那样在每个“包”之后才能收到ACK或者NAK标志信号，而是在连续传递几个“包”之后才能收到ACK或者NAK标志信号。设计者形象地把被传送的第一个数据”包”与后来收到的标志信号之间的时间段称作窗口。<br>正常状态时，WModem可准确检测到NAK的出现，并能确定哪一个“包”在传送时出现错误需要重新传送。由于WModem的窗口数据吞吐量较大，有较大内存缓冲区的系统才能可靠地接收，小内存的计算机是不能使用这个协议的。</p>
<h4 id="4-YModent-XModem-1K"><a href="#4-YModent-XModem-1K" class="headerlink" title=" 4.YModent/XModem 1K "></a><strong> 4.YModent/XModem 1K </strong></h4><p>YModem的工作方式与XModem几乎一样，不同点只是XModem的“包”有128个字节，而YModem的“包”有 1024个字节，所以YModem又叫 XModem 1K。由于YModem的“包”比XModem的“包”大出许多，因此非常适合传送篇幅很长的大块文件。在线路状况良好的情况下，将会有效地缩短传送时间。如果线路状况不佳，最好不要使用这个协议，因为频繁地重传那些被查出错误的大“包”肯定得不偿失。 </p>
<h4 id="5-YModem-Batch"><a href="#5-YModem-Batch" class="headerlink" title=" 5.YModem/Batch "></a><strong> 5.YModem/Batch </strong></h4><p>上面介绍的几个二进制文件传输协议在每次使用时只能传送一个数据文件，如果数个文件要传送到同一个接收系统，就只能在第一个文件传送结束后，再进行下一个文件的传送。频繁的操作和额外占用的处理时间，无疑给使用者带来了很多的不便。YModem/Batch协议可有效地解决这类难题。YModem/Batch能把一个以上的文件（包括文件名、字节数量等信息）按照事先编排的顺序一次性地传送给对方，其作用很象DOS系统的BAT批处理命令。接收系统收到文件后，可按需要把每个文件存人指定的驱动器和路径中。 </p>
<h4 id="6-YModem-G"><a href="#6-YModem-G" class="headerlink" title=" 6. YModem- G "></a><strong> 6. YModem- G </strong></h4><p>YModem－G是一种本身不提供检错或纠错能力的流式协议，除非有 MNP（Microsoft Networking Protocol）硬件协议的支持，否则不能使用。如果有MNP硬件为其提供服务的话， YModem－ G就会成为一个相当不错的协议，因为MNP硬件具有良好的检错和纠错能力。YModem－ G的每“包”容量也是1024个字节，但每一个“包”在传送后并不理会是否有接收端ACK的响应，只是不停地将所有的“包”都发出去，检错和纠错工作完全由MNP系统完成。与YModem－G合作的最佳硬件协议是MNP4。就传送速度而言，YModem－G肯定要比前面介绍的几种协议的速度快得多。</p>
<h4 id="7-Kermit"><a href="#7-Kermit" class="headerlink" title=" 7. Kermit "></a><strong> 7. Kermit </strong></h4><p>Kermit是一个既灵活又方便且非常有使用价值的协议，用户群较大。同其它文件传送协议一样， Kermit在传送文件时也是将数据打“包”并使用“校验和”。前面介绍的几种协议，不论是哪一种，只要一经选定，“包”的大小就会固定下来。Kermit“包”的大小则是随数据的整体结构和线路质量的变化而改变的。在理想的线路状态时“包”最大，大小为 1KB（1024字节）；线路质量下降时“包”就要随之变小，或是512字节、或是256字节、或是128字节。当线路出现瞬时中断时，Kermit能迅速恢复数据同步传输，这一点是其它协议无法比拟的。大多数协议都是用8数据位方式传送字符，Kermit则可在需要时将8数据位转换为7数据位传送，这样的转换使ASCⅡ字符集中的28个控制字节在传输中增加了可靠性。Kermit还有批处理的功能，可以用通配符“＊”代替文件名或扩展名传送数个文件，如在.TXT之前使用“*”就可以传送所有扩展名为TXT的文件。另外，如果文件中有的字符重复出现，Kermit会使用一种压缩处理技术，即重复字符只被传送一次，同时发送一组关键码告诉接收系统重复的次数和字符的位置，这样可以节省相当多的时间。</p>
<h4 id="8-ZModem"><a href="#8-ZModem" class="headerlink" title=" 8. ZModem "></a><strong> 8. ZModem </strong></h4><p>ZModem协议尽管是一个不太成熟的协议，但快速可靠的良好性能已使它受到越来越多人的喜爱。ZModem对“包”的处理与 Kermit相仿，“包”的大小也是取决于线路的质量好坏，并提供有效的32Bit或16Bit的CRC错误检测。ZModem具有高级文件管理特点，允许一次传送多份文件和自动上下载文件，操作简单方便。也能在传送意外中断后，迅速重新恢复数据的传送。在常规情况下，ZModem的传送可靠率能达到99％。</p>
<p>除了上述几种二进制文件传输协议在网络中经常出现外，还有某些系统协议也在文件传输中发挥着作用，如 CompuServe的 B协议和 B十协议以及 AmericaOnline等等。另有一些具有独自的文件传输能力和纠错技术的专有文件传输协议在个别系统中被使用，这种协议只能在特定的软硬件环境下才能起作用，不能在公共免费软件库、共享软件及商业通信中使用。 </p>
<p>总而言之，二进制文件传输协议是非常优秀的，只要应用得当就能收到良好的传送效果。这些协议的成品在大多数的通信软件包中均有提供，也可以通过BBS或从其它联机网络中下载得到。需要指出的是，由于版本的不同，收发两个系统间选定的同类协议的功能可能略有差异，是否能正常通信要取决于实验后的结果。目前使用最普遍的协议有XModem 7 ZModem和Kermit这三种，其中XModem使用的频率最高。</p>
<hr>
<p>在<code>SecureCRT</code>,<code>Xshell</code>中均是有<code>ASCII、Xmodem、Ymodem、Zmodem</code>这四种协议可选的。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title=" 参考 "></a><strong> 参考 </strong></h3><p><a href="https://www.cnblogs.com/zhengyihan1216/p/6260667.html" target="_blank" rel="noopener">Linux–用SecureCRT来上传和下载文件</a><br><a href="http://blog.51cto.com/skypegnu1/1538371" target="_blank" rel="noopener">Linux基础：利用SSH上传、下载（使用sz与rz命令）</a><br><a href="http://blog.csdn.net/xiaoluoshan/article/details/71773769" target="_blank" rel="noopener">Xmodem、Ymodem、Zmodem</a><br><a href="http://blog.csdn.net/tianlesoftware/article/details/7746005" target="_blank" rel="noopener">SecureCRT 工具 上传下载数据 与 ASCII、Xmodem、Ymodem 、Zmodem 说明</a><br><a href="https://baike.baidu.com/item/ssh/10407?fr=aladdin" target="_blank" rel="noopener">ssh （安全外壳协议）</a><br><a href="https://baike.baidu.com/item/ftp/13839?fr=aladdin" target="_blank" rel="noopener">ftp （文件传输协议）</a><br><a href="http://bbs.eeworld.com.cn/thread-556205-1-1.html" target="_blank" rel="noopener">几种流行的文件传输协议</a><br><a href="http://blog.csdn.net/geurney/article/details/48365295" target="_blank" rel="noopener">文件传输协议FTP、SFTP和SCP</a><br><a href="http://blog.csdn.net/qq_27803491/article/details/52785838" target="_blank" rel="noopener">linux把文件压缩成.tar.gz的命令</a></p>

  </section>

  
  
</article>


            <footer class="footer">
    <span class="footer__copyright">&copy; 2016-2021. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a> | <a href="https://www.miit.gov.cn/">渝ICP备17002561号</a> | 不装弱了,我要做大佬</span>
</footer>

<script>
// 对特定页面的footer隐藏
// function find(str, aim, num) {
//    var resultIndex = str.indexOf(aim);
//    for(var i = 0; i < num - 1; i++){
//        resultIndex = str.indexOf(aim, resultIndex + 1);
//    }
//    return resultIndex;
//  }

// var __one = document.querySelector("#__one");
// var __tow = document.querySelector("#__tow");
// var __three = document.querySelector("#__three");
// var __threeIndex  = find(location.href, '/', 3);
// var __fourthIndex = find(location.href, '/', 4);
// var aimStr = '';

// if (__fourthIndex !== -1) {
//     aimStr = location.href.substring(__threeIndex + 1, __fourthIndex);
// } else if (__fourthIndex === -1) {
//     aimStr = location.href.substring(__threeIndex + 1);
// }

// switch (aimStr) {
//   case "":
//   case "#blog":
//   case "about":
//   case "archive":
//   case "categories":
//   case "tags":
//   case "page":
//     __one.style.display = "none";
//     __tow.style.display = "none";
//     __three.style.display = "none";
//     break;
// }
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-137711129-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-137711129-1');
</script>

        </div>
    </div>



    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    <script>

var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        success: function( xmlResponse ) {
            // get the contents from search data

            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "link" , this).attr("href")
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length <= 0) {
                    return;
                }

                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {

                        str += "<li><a href='"+ data_url  +"' class='search-result-title'>"+ data_title +"</a>";
                       console.log(data_url);
                        console.log("=====命中=====", data);


                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 100;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substr(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<em class=\"search-keyword\">"+keyword+"</em>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                });
                str += "</ul>";
                $resultContent.innerHTML = str;
            });
        }
    });
};

var path = "/" + "search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>
