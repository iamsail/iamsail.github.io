<!DOCTYPE html>
<html>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      不再为正则烦恼 | Sail 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Sail">


    
    

<div id="site_search">
            <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control"/>
            <div id="local-search-result"></div>
    </div>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-1345496474366685",
        enable_page_level_ads: true
      });
    </script>


    <meta name="description" content="** Preface **有不少朋友都为写正则而头疼，不过笔者早已不为正则而烦恼了。本文分享一些我处理正则表达式的一些经验。全文分为正则利器，正则基础内容，正则进阶内容三个大块。  ** 正则利器 **首先推荐两个正则工具利器——分别是regex101(一个正则在线检验工具), Regulex(一个正则可视化工具)。这两个工具，可以大幅减小写正则的难度。做一个简单的演示,** 比如常见的密码校验:">
<meta property="og:type" content="article">
<meta property="og:title" content="不再为正则烦恼 | Sail">
<meta property="og:url" content="http://www.sail.name/2020/05/23/regular-expressions-without-trouble/index.html">
<meta property="og:site_name" content="Sail">
<meta property="og:description" content="** Preface **有不少朋友都为写正则而头疼，不过笔者早已不为正则而烦恼了。本文分享一些我处理正则表达式的一些经验。全文分为正则利器，正则基础内容，正则进阶内容三个大块。  ** 正则利器 **首先推荐两个正则工具利器——分别是regex101(一个正则在线检验工具), Regulex(一个正则可视化工具)。这两个工具，可以大幅减小写正则的难度。做一个简单的演示,** 比如常见的密码校验:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.sail.name/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/1.png">
<meta property="og:image" content="http://www.sail.name/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/2.png">
<meta property="og:image" content="http://www.sail.name/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/4.png">
<meta property="og:image" content="http://www.sail.name/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/3.png">
<meta property="og:image" content="http://www.sail.name/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/5.png">
<meta property="article:published_time" content="2020-05-23T05:31:45.000Z">
<meta property="article:modified_time" content="2025-04-16T10:39:38.510Z">
<meta property="article:author" content="Sail">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.sail.name/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/1.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    
<link rel="stylesheet" href="/css/uno.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    
<link rel="stylesheet" href="/css/archive.css">

    
<link rel="stylesheet" href="/css/china-social-icon.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="/custom_css_source.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>

    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Sail</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          手在键盘敲很轻
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>

              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>

              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>

              
               <li class="navigation__item">
                    <a href="http://www.sail.name/Resource/" title="个人资源分享">Resource</a></li>

            </ul>
          </nav>
          

<!-- add social info here -->



<nav class="cover-navigation navigation--social">
  <ul class="navigation">
    
      <!-- Github -->
      <li class="navigation__item">
        <a target="_blank" rel="noopener" href="https://github.com/iamsail" title="Huno on GitHub">
          <i class='icon icon-social-github'></i>
          <span class="label">GitHub</span>
        </a>
      </li>
    

    <!-- China social icon -->
    <!--
    
      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-douban'></i>
          <span class="label">Douban</span>
        </a>
      </li>

      <li class="navigation__item">
        <a href="" title="">
          <i class='icon cs-icon-weibo'></i>
          <span class="label">Weibo</span>
        </a>
      </li>

    -->



  </ul>
</nav>


        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">不再为正则烦恼</h1>

    

    <div class="post-meta">
      <time datetime="2020-05-23" class="post-meta__date date">2020-05-23</time> 

      <span class="post-meta__tags tags">

          
            <font class="categories">
            &#8226; 分类:
            <a class="categories-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
            </font>
          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="Preface"><a href="#Preface" class="headerlink" title="** Preface **"></a>** Preface **</h3><p>有不少朋友都为写正则而头疼，不过笔者早已不为正则而烦恼了。本文分享一些我处理正则表达式的一些经验。全文分为正则利器，正则基础内容，正则进阶内容三个大块。</p>
<hr>
<h3 id="正则利器"><a href="#正则利器" class="headerlink" title="** 正则利器 **"></a>** 正则利器 **</h3><p>首先推荐两个正则工具利器——分别是<a target="_blank" rel="noopener" href="https://regex101.com/">regex101</a>(一个正则在线检验工具), <a target="_blank" rel="noopener" href="https://jex.im/regulex/">Regulex</a>(一个正则可视化工具)。这两个工具，可以大幅减小写正则的难度。做一个简单的演示,** 比如常见的密码校验: 密码需要6位至18位，且只能为数字，字母，以及特殊字符,.* **</p>
<p>先使用<code>Regulex</code>来在线编写正则。借助其将正则图形化的功能，我们很容易来修改调整自己的正则。<br><img src="/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/1.png" alt="1.png"></p>
<p>当通过<code>Regulex</code>工具写完正则过后，可以使用<a target="_blank" rel="noopener" href="https://regex101.com/">regex101</a>来检查自己写的正则是否正确，以及匹配结果<br><img src="/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/2.png" alt="2.png"></p>
<p>当上面两个流程走通过后，意味着该正则是符合我们需求且正确无误的，就可以迁移入代码中啦。</p>
<hr>
<h3 id="手撕正则"><a href="#手撕正则" class="headerlink" title="** 手撕正则 **"></a>** 手撕正则 **</h3><p>**<span class="under0"> 关于正则的相关知识，我强烈推荐这篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html">正则表达式30分钟入门教程</a>。</span>**接下来我会将正则内容与JavaScript穿插起来讲。</p>
<h4 id="JS创建正则表达式"><a href="#JS创建正则表达式" class="headerlink" title="** JS创建正则表达式 **"></a>** JS创建正则表达式 **</h4><p>在JS里有两种创建正则表达式的方式，分别是字面量和调用<code>RegExp</code>对象的构造函数。<br>使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/ab+c/</span>;</span><br></pre></td></tr></table></figure>
<p>脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用此方法可获得更好的性能。</p>
<p>或者调用<code>RegExp</code>对象的构造函数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;ab+c&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在脚本运行过程中，用构造函数创建的正则表达式会被编译。** 如果正则表达式将会改变，或者它将会从用户输入等来源中动态地产生，就需要使用构造函数来创建正则表达式。**<br>总结一下，两种模式语法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/pattern/flags</span><br><span class="line">new RegExp(pattern [, flags])</span><br><span class="line">RegExp(pattern [, flags])</span><br><span class="line"></span><br><span class="line">参数如下:</span><br><span class="line">pattern</span><br><span class="line">    正则表达式的文本。</span><br><span class="line"></span><br><span class="line">flags</span><br><span class="line">    如果指定，标志可以具有以下值的任意组合：</span><br><span class="line"></span><br><span class="line">    g</span><br><span class="line">    全局匹配;找到所有匹配，而不是在第一个匹配后停止</span><br><span class="line">    </span><br><span class="line">    i</span><br><span class="line">    忽略大小写</span><br><span class="line">    </span><br><span class="line">    m</span><br><span class="line">    多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。</span><br><span class="line">    </span><br><span class="line">    u</span><br><span class="line">    Unicode; 将模式视为Unicode序列点的序列</span><br><span class="line">    </span><br><span class="line">    y</span><br><span class="line">    粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。</span><br><span class="line">    </span><br><span class="line">    s</span><br><span class="line">    dotAll模式，匹配任何字符（包括终止符 &#x27;\n&#x27;）。</span><br></pre></td></tr></table></figure>

<p>上面参数提到的全局匹配，粘性匹配的知识在本文后面将做细致的讲解。</p>
<hr>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="** 基础知识 **"></a>** 基础知识 **</h3><p>这里先了解一些基础的正则知识，不做过多的讲解。</p>
<p><strong>常用元字符</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线或汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或结束</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
</tbody></table>
<p><strong>常用限定符</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p><strong>常用的反义代码</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\B</td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td>[^x]</td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<h4 id="JS里的一些正则函数"><a href="#JS里的一些正则函数" class="headerlink" title="** JS里的一些正则函数 **"></a>** JS里的一些正则函数 **</h4><p>在 JavaScript中，正则表达式也是对象。这些模式被用于 <code>RegExp</code> 的 <code>exec</code> 和 <code>test</code> 方法, 以及 <code>String</code> 的 <code>match、matchAll、replace、search</code> 和 <code>split</code> 方法。</p>
<h4 id="test"><a href="#test" class="headerlink" title="** test **"></a>** test **</h4><p>test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello world!&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="regexp">/^hello/</span>.<span class="title function_">test</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); </span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<h4 id="exec"><a href="#exec" class="headerlink" title="** exec **"></a>** exec **</h4><p><code>exec()</code> 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。</p>
<p><span class="under0"> ** 在设置了 <code>global</code> 或 <code>sticky</code> 标志位的情况下（如 /foo/g or /foo/y），<code>JavaScript RegExp</code> 对象是有状态的。他们会将上次成功匹配后的位置记录在 <code>lastIndex</code> 属性中</span> **。使用此特性，<code>exec()</code> 可用来对单个字符串中的多次匹配结果进行逐条的遍历（包括捕获到的匹配），而相比之下， <code>String.prototype.match()</code> 只会返回匹配到的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex1 = <span class="title class_">RegExp</span>(<span class="string">&#x27;foo*&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;table football, foosball&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> array1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((array1 = regex1.<span class="title function_">exec</span>(str1)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Found <span class="subst">$&#123;array1[<span class="number">0</span>]&#125;</span>. Next starts at <span class="subst">$&#123;regex1.lastIndex&#125;</span>.`</span>);</span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 9.&quot;</span></span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 19.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>上面提到了正则表达式的<code>global</code>和<code>sticky</code> 两种模式，这里我详细讲下这两种模式。</p>
<h4 id="全局模式"><a href="#全局模式" class="headerlink" title="** 全局模式 **"></a>** 全局模式 **</h4><p><code>global</code>这里是指**<span class="under0">全局匹配——找到所有匹配，而不是在第一个匹配后停止</span>**。用前面提到的密码正则<code>^[\da-zA-Z,.*]&#123;6,18&#125;$</code>来举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 非全局模式</span><br><span class="line"><span class="keyword">var</span> keyword = <span class="string">&#x27;2020myTestkeyword,&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[\da-zA-Z,.*]&#123;6,18&#125;$/i</span>;   <span class="comment">// (i , 忽略大小写)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="property">lastIndex</span>, reg.<span class="title function_">test</span>(keyword)); <span class="comment">// 输出0 true  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="property">lastIndex</span>, reg.<span class="title function_">test</span>(keyword)); <span class="comment">// 输出0 true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="property">lastIndex</span>, reg.<span class="title function_">test</span>(keyword)); <span class="comment">// 输出0 true </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="property">lastIndex</span>, reg.<span class="title function_">test</span>(keyword)); <span class="comment">// 输出0 true </span></span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"># 全局模式</span><br><span class="line"><span class="keyword">var</span> keyword = <span class="string">&#x27;2020myTestkeyword,&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regG = <span class="regexp">/^[\da-zA-Z,.*]&#123;6,18&#125;$/ig</span>;   <span class="comment">// (i , 忽略大小写)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regG.<span class="property">lastIndex</span>, regG.<span class="title function_">test</span>(keyword)); <span class="comment">// 输出0 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regG.<span class="property">lastIndex</span>, regG.<span class="title function_">test</span>(keyword)); <span class="comment">// 输出18 false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regG.<span class="property">lastIndex</span>, regG.<span class="title function_">test</span>(keyword)); <span class="comment">// 输出0 true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(regG.<span class="property">lastIndex</span>, regG.<span class="title function_">test</span>(keyword)); <span class="comment">// 输出18 false</span></span><br></pre></td></tr></table></figure>

<p>上面的两段代码可以看到在全局模式下，正则的匹配结果为，true和false依次交替。这是因为: ** 在全局匹配模式下可以对指定要查找的字符串执行多次匹配。每次匹配使用当前正则对象的<code>lastIndex</code>属性的值作为在目标字符串中开 始查找的起始位置。<code>lastIndex</code>属性的初始值为0，找到匹配的项后lastIndex的值被重置为匹配内容的下一个字符在字符串中的位置索引，用来标识下次执行匹配时开始查找的位置。如果找不到匹配的项<code>lastIndex</code>的值会被设置为0。当没有设置正则对象的全局匹配标志时<code>lastIndex</code>属性的值始终为0，每次执行匹配仅查找字符串中第一个匹配的项。** <code>lastIndex</code>, 是一个可读可写的属性。需要特别注意是的，如前所述，正则表达当指定了g(全局匹配)或者y(粘性匹配)，均会有这个效果。</p>
<p>全局匹配的一个使用场景——循环遍历,获取所有匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((result = globalre.<span class="title function_">exec</span>(str)) != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">0</span>]);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(globalre.<span class="property">lastIndex</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll">matchAll()</a>方法也可以实现该效果，这里不再赘述。</p>
<hr>
<h4 id="粘性匹配"><a href="#粘性匹配" class="headerlink" title="** 粘性匹配 **"></a>** 粘性匹配 **</h4><p><code>sticky</code> 属性反映了搜索是否具有粘性（ 仅从正则表达式的 lastIndex 属性表示的索引处搜索 ）。<code>sticky</code>是正则表达式对象的只读属性。<code>sticky</code> 的值是 Boolean ，并在“y”标志使用时为真; 否则为假。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;#foo#&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/foo/y</span>;</span><br><span class="line"></span><br><span class="line">regex.<span class="property">lastIndex</span> = <span class="number">1</span>;</span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// true （译注：此例仅当 lastIndex = 1 时匹配成功，这就是 sticky 的作用）</span></span><br><span class="line">regex.<span class="property">lastIndex</span> = <span class="number">5</span>;</span><br><span class="line">regex.<span class="title function_">test</span>(str); <span class="comment">// false （lastIndex 被 sticky 标志考虑到，从而导致匹配失败）</span></span><br><span class="line">regex.<span class="property">lastIndex</span>; <span class="comment">// 0 （匹配失败后重置）</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="进阶知识"><a href="#进阶知识" class="headerlink" title="** 进阶知识 **"></a>** 进阶知识 **</h3><p>接下来我会讲一下，正则里面比较进阶且我觉得比较重要的内容。如前所述，这部分内容，我强烈推荐阅读这篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html">正则表达式30分钟入门教程</a>。为了不做重复工作，这里我会讲得比较简略。</p>
<h4 id="分支"><a href="#分支" class="headerlink" title="** 分支 **"></a>** 分支 **</h4><p>所谓分支，是指有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用<code>|</code>把不同的规则分隔开。<code>0\d&#123;2&#125;-\d&#123;8&#125;|0\d&#123;3&#125;-\d&#123;7&#125;</code></p>
<iframe frameborder="0" width="384" height="194" src="https://jex.im/regulex/#!embed=true&flags=&re=0%5Cd%7B2%7D-%5Cd%7B8%7D%7C0%5Cd%7B3%7D-%5Cd%7B7%7D"></iframe>

<h4 id="分组"><a href="#分组" class="headerlink" title="** 分组 **"></a>** 分组 **</h4><p>所谓分组，类似于编码中的表达式的功能。用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了。如下所示<code>(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;</code></p>
<iframe frameborder="0" width="388" height="193" src="https://jex.im/regulex/#!embed=true&flags=&re=(%5Cd%7B1%2C3%7D%5C.)%7B3%7D%5Cd%7B1%2C3%7D"></iframe>

<h4 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="** 贪婪与懒惰 **"></a>** 贪婪与懒惰 **</h4><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。<br><img src="/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/4.png" alt="4.png"></p>
<p>有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>即可。懒惰限定符如下</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,m}?</td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,}?</td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<p><code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。<br><img src="/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/3.png" alt="3.png"></p>
<h4 id="断言"><a href="#断言" class="headerlink" title="** 断言 **"></a>** 断言 **</h4><p>**<span class="under0"> 接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西， </span>**也就是说它们像<code>\b,^,$</code>那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。</p>
<h4 id="先行断言"><a href="#先行断言" class="headerlink" title="** 先行断言 **"></a>** 先行断言 **</h4><p><code>x(?=exp)</code>，先行断言: exp紧跟x的情况下匹配x。例如，对于<code>/Jack(?=Sprat)/</code>，“Jack”在跟有“Sprat”的情况下才会得到匹配．<code>/Jack(?=Sprat)/</code> “Jack”后跟有“Sprat”或“Frost”的情况下才会得到匹配。不过， 匹配结果不包括“Sprat”或“Frost”。</p>
<iframe frameborder="0" width="260" height="117" src="https://jex.im/regulex/#!embed=true&flags=&re=Jack(%3F%3DSprat)"></iframe>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/First(?= test)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;First test&#x27;</span>.<span class="title function_">match</span>(regex)); <span class="comment">// [ &#x27;First&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;First peach&#x27;</span>.<span class="title function_">match</span>(regex)); <span class="comment">// null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is a First test in a year.&#x27;</span>.<span class="title function_">match</span>(regex)); <span class="comment">// [ &#x27;First&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is a First peach in a month.&#x27;</span>.<span class="title function_">match</span>(regex)); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>


<h4 id="负向先行断言"><a href="#负向先行断言" class="headerlink" title="** 负向先行断言 **"></a>** 负向先行断言 **</h4><p><code>x(?!exp)</code>,负向先行断言: x后无exp紧随的情况下匹配x。例如，对于<code>/\d+(?!\。)/</code>，数字后没有跟随小数点的情况下才会得到匹配。对于<code>/\d+(?!\.)/.exec(3.141)</code>，匹配‘141’而不是‘3’。</p>
<iframe frameborder="0" width="369" height="143" src="https://jex.im/regulex/#!embed=true&flags=g&re=%5Cd%2B(%3F!%5C%E3%80%82)"></iframe>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/\d+(?!\.)/g</span>.<span class="title function_">exec</span>(<span class="string">&#x27;3.141&#x27;</span>)); <span class="comment">// [ &#x27;141&#x27;, index: 2, input: &#x27;3.141&#x27; ]</span></span><br></pre></td></tr></table></figure>


<h4 id="后行断言"><a href="#后行断言" class="headerlink" title="** 后行断言 **"></a>** 后行断言 **</h4><p><code>(?&lt;=exp)x</code>,后行断言: x紧随exp的情况下匹配x。例如，对于<code>/(?&lt;=Jack)Sprat/</code>，“Sprat”紧随“Jack”时才会得到匹配。对于<code>/(?&lt;=Jack|Tom)Sprat</code>，“Sprat”在紧随“Jack”或“Tom”的情况下才会得到匹配。不过，匹配结果中不包括“Jack”或“Tom”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oranges = [<span class="string">&#x27;ripe orange A &#x27;</span>, <span class="string">&#x27;green orange B&#x27;</span>, <span class="string">&#x27;ripe orange C&#x27;</span>,];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ripe_oranges = oranges.<span class="title function_">filter</span>( <span class="function"><span class="params">fruit</span> =&gt;</span> fruit.<span class="title function_">match</span>(<span class="regexp">/(?&lt;=ripe )orange/</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ripe_oranges); <span class="comment">// [ &#x27;ripe orange A &#x27;, &#x27;ripe orange C&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="负向后行断言"><a href="#负向后行断言" class="headerlink" title="** 负向后行断言 **"></a>** 负向后行断言 **</h4><p><code>(?&lt;!exp)x</code>,负向后行断言: x不紧随y的情况下匹配x。例如，对于<code>/(?&lt;!-)\d+/</code>，数字紧随-符号的情况下才会得到匹配。对于<code>/(?&lt;!-)\d+/.exec(3)</code> ，“3”得到匹配。 而<code>/(?&lt;!-)\d+/.exec(-3)</code>的结果无匹配，这是由于数字之前有-符号。</p>
<h4 id="断言实战"><a href="#断言实战" class="headerlink" title="** 断言实战 **"></a>** 断言实战 **</h4><p>提取字符串<code>123sadf21(aaaaf213sdaf)</code>,括号中的部分。</p>
<p><img src="/img/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/regular-expressions-without-trouble/5.png" alt="5.png"></p>
<p>如上图所示，<code>(?&lt;=\().+(?=\))</code>, 该正则分为三部分：<code>(?&lt;=\(</code>，这是后行断言；<code>(?=\))</code>, 这是先行断言；<code>.+</code>,匹配任意长的字符。</p>
<hr>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="** 写在最后 **"></a>** 写在最后 **</h3><p>以上就是本文的所有内容。正则使用得好，能起到事半功倍的作用。利用好本文推荐的工具，多加练习，相信正则一定不再是烦恼！</p>
<hr>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="** 参考链接 **"></a>** 参考链接 **</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html">正则表达式30分钟入门教程</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">mdn-正则表达式</a></li>
</ul>

  </section>

  
  
</article>


            <footer class="__share_wrapper">
    <span class="under0">
		<span class="text">关注我的微信公众号[<a href="/about/">李一二</a>]，即时看更多的文章</span>
	</span>
</footer>

<footer class="footer">
    <span class="footer__copyright">&copy; 2016-2021. | 由<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a target="_blank" rel="noopener" href="https://github.com/someus/huno">Huno</a> | <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">渝ICP备17002561号</a> | 不装弱了,我要做大佬</span>
</footer>

<script>
// 对特定页面的footer隐藏
// function find(str, aim, num) {
//    var resultIndex = str.indexOf(aim);
//    for(var i = 0; i < num - 1; i++){
//        resultIndex = str.indexOf(aim, resultIndex + 1);
//    }
//    return resultIndex;
//  }

// var __one = document.querySelector("#__one");
// var __tow = document.querySelector("#__tow");
// var __three = document.querySelector("#__three");
// var __threeIndex  = find(location.href, '/', 3);
// var __fourthIndex = find(location.href, '/', 4);
// var aimStr = '';

// if (__fourthIndex !== -1) {
//     aimStr = location.href.substring(__threeIndex + 1, __fourthIndex);
// } else if (__fourthIndex === -1) {
//     aimStr = location.href.substring(__threeIndex + 1);
// }

// switch (aimStr) {
//   case "":
//   case "#blog":
//   case "about":
//   case "archive":
//   case "categories":
//   case "tags":
//   case "page":
//     __one.style.display = "none";
//     __tow.style.display = "none";
//     __three.style.display = "none";
//     break;
// }
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-137711129-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-137711129-1');
</script>

        </div>
    </div>



    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    <script>

var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        success: function( xmlResponse ) {
            // get the contents from search data

            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "link" , this).attr("href")
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length <= 0) {
                    return;
                }

                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {

                        str += "<li><a href='"+ data_url  +"' class='search-result-title'>"+ data_title +"</a>";
                       console.log(data_url);
                        console.log("=====命中=====", data);


                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 100;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substr(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<em class=\"search-keyword\">"+keyword+"</em>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                });
                str += "</ul>";
                $resultContent.innerHTML = str;
            });
        }
    });
};

var path = "/" + "search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
